---
title: "Final Report"
author: "Olivia Hofmann, Matias Barcelo, and Mike Perkins"
date: "2024-11-13"
output:
  pdf_document:
    fig_caption: true
    toc: true
    toc_depth: 4
  html_document:
    toc: true
    toc_depth: '4'
    df_print: paged
header-includes: \usepackage{caption}
---
```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

\newpage

# Problem Description (Business Understanding)
COVID-19 is a highly contagious respiratory illness that first emerged in Wuhan, China in December 2019. COVID-19 entered the United States in January 2020 with the World Health Organization (WHO) declaring COVID-19 a “global health emergency” in March 2020. The virus spreads through respiratory droplets dispersed when someone coughs, sneezes, or even talks. COVID-19 can cause symptoms including those similar to a cold, influenza, or pneumonia with the potential to become very severe and lead to death. The COVID-19 virus overwhelmed healthcare systems and disrupted economies around the world. [1] [2]

The stakeholder for this data analysis is a property developer who is interested in determining the best location in Texas for developing a mixed-use building. The stakeholder’s key concern is selecting a county that demonstrates stability and resilience in response to unpredictable events, like the COVID-19 pandemic. The mixed-use building that the stakeholder is looking to develop will have space for a gym, restaurants, pharmacy, and other similar businesses. When deciding where to build this mixed-use building, the stakeholder is looking for insights into which counties in Texas have successfully managed public health crises as situations similar to this would greatly impact the success of the businesses within his building. Every business that would be in the mixed-use building would be heavily reliant on consistent traffic and economic activity. Any change in foot traffic and economic activity would directly impact the success or failure of each business. The analysis will include data on COVID-19 cases, COVID-19 deaths, and the effectiveness of government interventions (such as lock downs and social distancing). This analysis is crucial for the stakeholder to make an informed decision regarding this long-term investment, as counties that respond well to crises are more likely to provide stable environments for growth and development.

Some questions that the stakeholder would like answered are:

 - What are the characteristics of counties in Texas that showed resilience during the COVID-19 pandemic, based on COVID-19 case rates?
 - What are the economic and social impacts in counties that were more or less affected by the pandemic and how might these influence future development potential?
 - How did COVID-19 impact the workplace and employment rates in the various counties?
 - Which counties showed consistent consumer foot traffic during the pandemic, indicating stable economic activity?

All of these questions are critical because the answers will help the property developer asses the risk and potential returns on his investment. Data needed to complete this analysis includes COVID-19 data for the state of Texas, COVID-19 date for the entire United States, and COVID-19 mobility data for the world. While these datasets seem broad, each dataset contains necessary features to conduct this analysis, which will be revealed further in the report. By understanding how different counties fared during the pandemic, the developer can make an informed decision regarding where he wants to build, ensuring that the chosen location offers stability and growth potential, even during unforeseen circumstances.

\newpage

# Income Data in Texas Counties
## Data Collection, Quality, and Exploration
```{r install packages, echo = FALSE, message = FALSE, warning = FALSE, error = FALSE}
# Install only missing packages, load required libraries
pkgs <- c("dplyr", "tidyr", "knitr", "kableExtra", "ggplot2", "cluster", "factoextra", "stringr", "purrr")

new_pkgs <- pkgs[!pkgs %in% installed.packages()[, "Package"]]
if(length(new_pkgs)) install.packages(new_pkgs)
invisible(lapply(pkgs, library, character.only = TRUE))
```

```{r load data, echo = FALSE}
# Load and filter Texas data
data <- read.csv("data/COVID-19_cases_plus_census.csv") %>%
  filter(state == "TX") %>%
  select(county_name, confirmed_cases, deaths, total_pop, median_income, income_per_capita,
         rent_over_50_percent, rent_30_to_35_percent, income_less_10000, 
         income_50000_59999, income_100000_124999)

# Add a column for the deaths/confirmed cases ratio
data <- data %>%
  mutate(death_case_ratio = deaths / confirmed_cases)
```

### Objects to Cluster
The objects to be clustered in this analysis are the counties in Texas. To identify which counties demonstrated resilience during the COVID-19 pandemic, income and rent burden metrics will be analyzed alongside general population data. Some key features for clustering include median income, income per capita, a couple rent burden levels, and a few income distribution brackets. These factors provide a comprehensive picture of each county’s economic resilience and ability to maintain stability during times of crisis.

By examining income distribution and wealth concentration, we can determine which counties have strong economic foundations. This, in combination with COVID-19 case and death data, will guide the stakeholder in making an informed decision on where to invest in developing a mixed-use building. Counties that managed to sustain consumer traffic and economic activity during the pandemic will likely offer more stability and growth potential for future business ventures.

### Features for Clustering
The features analyzed for clustering relate to the category of income and wealth, which are critical for understanding economic resilience. These features include income brackets, median income per capita, rent burden percentages, and population statistics. Each of these features play a significant role in assessing to what capacity the county can withstand a widespread challenge such as the COVID-19 pandemic. 

  - **Income Levels:** The distribution of households across various income levels can provide insight into a county's overall economic health and resilience.
  - **Rent Burden:** High rent burden percentages indicate financial strain on households, which can affect their ability to manage crises effectively.
  - **Median Income and Income per Capita:** These metrics serve as broad indicators of wealth within a county. Wealthier counties typically have more resources to navigate economic shocks and support their communities during difficult times.
  - **Population:** Including population statistics allows for a more accurate interpretation of COVID-19 impacts by normalizing the number of cases and deaths based on county size.

By clustering counties based on these features, we can identify different income and wealth profiles that may correlate with their resilience during the pandemic. This analysis will enhance our understanding of which counties were better equipped to handle the economic and social disruptions caused by COVID-19, ultimately aiding the stakeholder in making informed investment decisions.

### Table of Features and Basic Statistics
```{r basic statistics, echo = FALSE}
# Corrected calculation of basic statistics for each feature individually
stats <- data %>%
  summarise(
    median_income_mean = mean(median_income, na.rm = TRUE),
    median_income_sd = sd(median_income, na.rm = TRUE),
    median_income_min = min(median_income, na.rm = TRUE),
    median_income_max = max(median_income, na.rm = TRUE),
    
    income_per_capita_mean = mean(income_per_capita, na.rm = TRUE),
    income_per_capita_sd = sd(income_per_capita, na.rm = TRUE),
    income_per_capita_min = min(income_per_capita, na.rm = TRUE),
    income_per_capita_max = max(income_per_capita, na.rm = TRUE),
    
    rent_over_50_percent_mean = mean(rent_over_50_percent, na.rm = TRUE),
    rent_over_50_percent_sd = sd(rent_over_50_percent, na.rm = TRUE),
    rent_over_50_percent_min = min(rent_over_50_percent, na.rm = TRUE),
    rent_over_50_percent_max = max(rent_over_50_percent, na.rm = TRUE),
    
    rent_30_to_35_percent_mean = mean(rent_30_to_35_percent, na.rm = TRUE),
    rent_30_to_35_percent_sd = sd(rent_30_to_35_percent, na.rm = TRUE),
    rent_30_to_35_percent_min = min(rent_30_to_35_percent, na.rm = TRUE),
    rent_30_to_35_percent_max = max(rent_30_to_35_percent, na.rm = TRUE),
    
    income_less_10000_mean = mean(income_less_10000, na.rm = TRUE),
    income_less_10000_sd = sd(income_less_10000, na.rm = TRUE),
    income_less_10000_min = min(income_less_10000, na.rm = TRUE),
    income_less_10000_max = max(income_less_10000, na.rm = TRUE),
    
    income_50000_59999_mean = mean(income_50000_59999, na.rm = TRUE),
    income_50000_59999_sd = sd(income_50000_59999, na.rm = TRUE),
    income_50000_59999_min = min(income_50000_59999, na.rm = TRUE),
    income_50000_59999_max = max(income_50000_59999, na.rm = TRUE),
    
    income_100000_124999_mean = mean(income_100000_124999, na.rm = TRUE),
    income_100000_124999_sd = sd(income_100000_124999, na.rm = TRUE),
    income_100000_124999_min = min(income_100000_124999, na.rm = TRUE),
    income_100000_124999_max = max(income_100000_124999, na.rm = TRUE),
    
    total_pop_mean = mean(total_pop, na.rm = TRUE),
    total_pop_sd = sd(total_pop, na.rm = TRUE),
    total_pop_min = min(total_pop, na.rm = TRUE),
    total_pop_max = max(total_pop, na.rm = TRUE)
  )

# Reshape the stats for better display
feature_stats <- tibble::tibble(
  Feature = c("Median Income", "Income per Capita", "Rent > 50% Income", 
              "Rent 30-35% Income", "Income < 10,000 USD", "Income 50,000-59,999 USD",
              "Income 100,000-124,999 USD", "Total Population"),
  
  Mean = c(stats$median_income_mean, stats$income_per_capita_mean, stats$rent_over_50_percent_mean,
           stats$rent_30_to_35_percent_mean, stats$income_less_10000_mean, stats$income_50000_59999_mean,
           stats$income_100000_124999_mean, stats$total_pop_mean),
  
  SD = c(stats$median_income_sd, stats$income_per_capita_sd, stats$rent_over_50_percent_sd,
         stats$rent_30_to_35_percent_sd, stats$income_less_10000_sd, stats$income_50000_59999_sd,
         stats$income_100000_124999_sd, stats$total_pop_sd),
  
  Min = c(stats$median_income_min, stats$income_per_capita_min, stats$rent_over_50_percent_min,
          stats$rent_30_to_35_percent_min, stats$income_less_10000_min, stats$income_50000_59999_min,
          stats$income_100000_124999_min, stats$total_pop_min),
  
  Max = c(stats$median_income_max, stats$income_per_capita_max, stats$rent_over_50_percent_max,
          stats$rent_30_to_35_percent_max, stats$income_less_10000_max, stats$income_50000_59999_max,
          stats$income_100000_124999_max, stats$total_pop_max)
)

# Display the corrected table
kable(feature_stats, format = "markdown", caption = "Basic Statistics of Key Features") %>%
  kable_styling(full_width = FALSE, font_size = 10)
```

Because there are a lot of features that represent the wealth and income category, features were chosen that represent the most critical dimensions of income distribution and rent burden, while avoiding overly granular breakdowns. This selection captures the distribution of wealth (from low to high incomes), general population data, and rent burden, which are the most relevant features for analyzing the economic stability of a county.

  - **Median Income:** This gives a central measure of income distribution in a county.
  - **Income per Capita:** Shows wealth distribution on a per-person basis, which complements median income.
  - **Rent Over 50 Percent:** This is a key indicator of severe rent burden, which can signify economic strain in a county.
  - **Rent 30 to 35 Percent:** This provides a threshold of moderate rent burden.
  - **Income Less than $10,000:** Reflects the population in extreme poverty, which is crucial for understanding economic vulnerability.
  - **Income $50,000 - $59,999:** Represents household earning within a middle-income bracket, which can provide insight to stability of the county's middle class.
  - **Income $100,000 - $124,999:** Indicates a higher income range, reflecting the proportion of relatively affluent residents. 

### Scale of Measurement

All of the features listed below are ratio scales because they have a true zero point (e.g., zero income, zero population) and allow for meaningful arithmetic operations (e.g., calculating differences, ratios).

```{r scale of measurement, echo = FALSE}
# Table defining measurement scales for features
measurement_scales <- data.frame(
  Feature = c("Median Income", "Income per Capita", "Rent > 50% Income", 
              "Rent 30-35% Income", "Income <10,000 USD", "Income 50,000-59,999 USD",
              "Income 100,000-124,999 USD", "Total Population"),
  Scale = "Ratio",
  Description = c("Income in USD", "Per capita income in USD", 
                  "Households paying >50% income in rent", "Households paying 30-35% income in rent",
                  "Households earning <10,000 USD", "Households earning 50,000-59,999 USD",
                  "Households earning 100,000-124,999 USD", "Total county population")
)

# Display table
kable(measurement_scales, format = "markdown", caption = "Measurement Scales for Features") %>%
  kable_styling(full_width = FALSE, font_size = 10)
```

### Measures for Similarity/Distance

For clustering analysis, various measures of similarity or distance can be employed based on the features used. The following measures are particularly relevant:

  - **Euclidean Distance:** This is the most widely used distance measure, calculated as the straight-line distance between points in a multi-dimensional space. It is especially effective for continuous numerical data such as income or population figures, where the relationships between data points can be interpreted geometrically. Euclidean distance captures the direct linear relationship between observations, making it intuitive and straightforward for visualizing proximity in clustering contexts. [3]
  - **Manhattan Distance:** This measure calculates the distance between two points by summing the absolute differences of their coordinates. Manhattan distance is useful when dealing with outliers or when the scale of measurement varies among features. It reflects a grid-like path, which can be advantageous in scenarios where a more robust metric against extreme values is required. In urban environments, for example, it mirrors the layout of streets. [4]
  - **Standardization/Normalization:** When features exhibit wide ranges, normalizing the data before applying distance measures is beneficial. This ensures that each feature contributes equally to the distance calculation, preventing features with larger scales from disproportionately influencing results. [5]

In this analysis, a combination of standardized/normalized distance and Euclidean distance will be utilized. The data will first be standardized to ensure that each feature contributes equally to the distance calculation. The choice of Euclidean distance is justified by its prevalence and effectiveness for income and population data, which typically exhibit continuous numerical characteristics. It provides a clear and meaningful way to measure similarity between counties based on economic and demographic factors.

### Normalization/Standardization
Standardization is essential for putting features on a similar scale, enabling meaningful comparisons across variables and preventing features with larger ranges or counts from dominating the analysis—especially in clustering algorithms. Given the wide range of values in the dataset, it was necessary to standardize the numerical features before proceeding with clustering or further analysis. The standardization was done using R and it transforms the data such that each feature has a mean of 0 and a standard deviation of 1. The county name was not standardized since it is a categorical variable. Since standardization is applied to numerical data, this feature was excluded from the process.


## Modeling and Evaluation
### K-Means Clustering
The K-Means clustering plot shows how Texas counties are grouped into two distinct clusters (1 and 2). Each point on the plot represents a county, and the clusters are visualized using different shapes and colors. The boarder around each cluster provides a visual boundary for each group. This clustering helps uncover patterns among the counties based on their economic resilience during the COVID-19 pandemic. 

\vspace{10pt}

```{r k-means clustering, echo=FALSE}
# Scaling the selected features (excluding county_name)
scaled_data_kmean <- data %>%
  select(-county_name) %>%
  scale()

# Perform K-means clustering
set.seed(123)
kmeans_result <- kmeans(scaled_data_kmean, centers = 2, nstart = 20)

# Append cluster assignments to the original data
data_clustered_1<- data %>%
  mutate(cluster = as.factor(kmeans_result$cluster))

# Visualization of Clustering
fviz_cluster(kmeans_result, data = scaled_data_kmean,
             geom = "point", ellipse.type = "convex",
             ggtheme = theme_minimal(), labelsize = 10) +
  labs(title = "K-Means Clustering of Texas Counties",
       x = "Dimension 1", y = "Dimension 2")
```

\captionof{figure}{K-Means Clustering of Texas Counties}

\vspace{10pt}

A summary statistics table is used to provide a detailed breakdown of the average values for key features across the two clusters identified through K-Means clustering. Each cluster represents a distinct group of Texas counties with similar economic, demographic, and pandemic characteristics. The table displays the average median income, income per capita, rent burden levels (both for households spending more than 50% and 30-35% of their income on rent), confirmed COVID-19 cases, deaths, and total population for each cluster.

```{r k-means summary statistics by cluster, echo=FALSE}
# Calculate average values for each feature by cluster with adjusted column names
cluster_summary <- data_clustered_1 %>%
  group_by(cluster) %>%
  summarise(
    "Avg\nMedian\nIncome" = mean(median_income, na.rm = TRUE),
    "Avg\nIncome\nper Capita" = mean(income_per_capita, na.rm = TRUE),
    "Avg\nRent\n> 50%" = mean(rent_over_50_percent, na.rm = TRUE),
    "Avg\nRent\n30-35%" = mean(rent_30_to_35_percent, na.rm = TRUE),
    "Avg\nConfirmed\nCases" = mean(confirmed_cases, na.rm = TRUE),
    "Avg\nDeaths" = mean(deaths, na.rm = TRUE),
    "Total\nPopulation" = mean(total_pop, na.rm = TRUE)
  )

# Display the summary statistics table with narrower columns and smaller font size
kable(cluster_summary, format = "latex", caption = "Summary Statistics by Cluster", booktabs = TRUE) %>%
  kable_styling(latex_options = c("hold_position"), font_size = 7, full_width = FALSE) %>%
  column_spec(0:7, width = "1.5cm")
```

Cluster 1 has a high concentration of points while Cluster 2 captures a much smaller group. This incredibly uneven distribution suggests the clustering is not a great representation of the counties.
  
\vspace{5pt}

  - **Average Median Income:** Cluster 1 had an average median income of 47,780.86 USD and Cluster 2 had an average median income of 56,987.00 USD. This shows a very moderate income difference of less than 10,000 USD. 
  - **Average Deaths:** This is a pretty big discrepancy as Cluster 2 experiences 2,529 average deaths while Cluster 1 only experienced 89. This indicates that Cluster 2 captures a very specific subset of counties with higher COVID-19 mortality.

\vspace{5pt}
  
This clustering does not offer a clear, interpretable division aligned with economic or pandemic impact metrics, as variation between clusters in largely skewed. This unsupervised K-Means clustering could perform better with supervision. 

#### Suitable Number of Clusters
The Elbow Method plots the WSS (Within-Cluster Sum of Squares) for different number of clusters. WSS measures how tightly the data points are grouped around the centroids of the clusters. After a certain point, adding more clusters provides diminishing returns, meaning the reduction in WSS becomes negligible. The optimal number of clusters is found at the "elbow" point, where the rate of decrease in WSS sharply levels off. In the following elbow plot, the elbow occurs around 2 clusters. 

\vspace{10pt}

```{r k-means optimal cluster, echo=FALSE}
# Elbow Method
# fviz_nbclust(scaled_data_kmean, kmeans, method = "wss") + labs(title = "Elbow Method for Determining Optimal Clusters")

# Calculate total within-cluster sum of squares for different values of k
wss <- sapply(1:10, function(k) {
  kmeans(scaled_data_kmean, centers = k, nstart = 20)$tot.withinss
})


# Add a placeholder for k = 1 with silhouette width of 0
elbow_data <- data.frame(
  k = 1:10,
  wss
)

# Create the elbow plot using ggplot2
ggplot(elbow_data, aes(x = k, y = wss)) +
  geom_point(size = 3) +  # Adjust point size for visibility
  geom_line(linewidth = 1) +  # Use linewidth instead of size for line thickness
  labs(title = "Elbow Method for Determining Optimal Clusters",
       x = "Number of clusters k",
       y = "Total Within Sum of Square") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14),  # Center and adjust title size
    axis.title = element_text(size = 12),              # Adjust axis title size
    axis.text = element_text(size = 10)                # Adjust axis text size
  )
```

\captionof{figure}{Elbow Method for Determining Optimal Clusters}

\vspace{10pt}

The Silhouette Method evaluates how well each data point fits within its assigned cluster compared to other clusters. The Silhouette score ranges from -1 to 1, with values close to 1 meaning that the points are well-clustered. In the following Silhouette chart, the peak occurs at 2 clusters. 

\vspace{10pt}

```{r k-means optimal cluster silhouette, echo=FALSE}
# Silhouette Method
# fviz_nbclust(scaled_data_kmean, kmeans, method = "silhouette") + labs(title = "Silhouette Method for Determining Optimal Clusters")

# Calculate average silhouette width for k = 2 to 10
sil_widths <- sapply(2:10, function(k) {
  km_res <- kmeans(scaled_data_kmean, centers = k, nstart = 20)
  silhouette_widths <- silhouette(km_res$cluster, dist(scaled_data_kmean))
  mean(silhouette_widths[, 3])  # Extract the average silhouette width
})

# Add a placeholder for k = 1 with silhouette width of 0
sil_data <- data.frame(
  k = 1:10,
  sil_width = c(0, sil_widths)  # Add 0 for k = 1
)

# Plot the silhouette method results using ggplot2
ggplot(sil_data, aes(x = k, y = sil_width)) +
  geom_point(size = 3) +  # Larger points for visibility
  geom_line(linewidth = 1) +   # Use linewidth for line thickness
  geom_vline(xintercept = 2, linetype = "dashed", color = "blue") +  # Dashed vertical line
  labs(title = "Silhouette Method for Determining Optimal Clusters",
       x = "Number of clusters k",
       y = "Average silhouette width") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14),  # Center and adjust title size
    axis.title = element_text(size = 12),              # Adjust axis title size
    axis.text = element_text(size = 10)                # Adjust axis text size
  )
```

\captionof{figure}{Silhouette Method for Determining Optimal Clusters}

\vspace{10pt}

After considering both of these models, it was decided to do 2 clusters. Because of the consistency across both methods, 2 clusters was the clear choice. 

#### Unsupervised Evaluation
A silhouette plot is used as the unsupervised evaluation to assess the quality and cohesion of clusters generated by the K-Means algorithm. The silhouette width is a metric used to evaluate how well each data point fits within its assigned cluster relative to other clusters. Values near 1 indicate that data points are well-matched to their own cluster and poorly matched to neighboring clusters (high-quality clustering). Values near 0 suggest that the data points lie equally far from two neighboring clusters (uncertainty in clustering assignments).

\vspace{10pt}

```{r heirarchical silhouette plot, echo=FALSE}
# Plot silhouette scores for each cluster
fviz_silhouette(silhouette(kmeans_result$cluster, dist(scaled_data_kmean)),
                title = "Silhouette Plot for K-Means Clustering") +
  labs(x = "Silhouette Width", y = "Clusters")
```

\captionof{figure}{Silhouette Plot for K-Means Clustering}

\vspace{10pt}

  - **Cluster 1 (Red):** The size of this cluster is 250 points with an average silhouette width of 0.87. This can be interpreted to mean that most of the data points are well-separated from other clusters and they have a high degree of cohesion. Cluster 1 can be defined as compact and well-defined within the data. 
  - **Cluster 2 (Blue):** The size of this cluster is 4 points with an average silhouette width of 0.45. This can be interpreted to mean that the points within the cluster are less cohesive and lack a clear grouping, leading to a weaker clustering group.


#### Ground Truth Feature
The feature used for the ground truth features is the COVID-19 deaths, comparing the clusters to the death-to-case ratio category (Lower: <0.025, Higher: >0.025). The motivation for choosing this feature as the ground truth feature stems from the goal of examining how wealth and economic conditions impacted the pandemic outcomes. 

\vspace{5pt}

  - The analysis seeks to determine if wealthier counties, indentified through income-realted clustering, exhibit better pandemic performance measured through lower mortality rates relative to confirmed cases. 
  - By using "Lower" and "Higher" categories, the analysis is simplfied, making it easier to interpret and compare income groups. Additionally, to truly show a comparison between unsupervised and supervised clustering, it was decided to stay consistent with 2 clustering groups. 
  - Mortality rates serve as a crutial public health indicator, directly reflecting the severity of the pandemic's impact on a county. This feature can provide meaningful insight into how income of a county can indicate resilience and lower mortality rates for a pandemic like COVID-19. 
  
\vspace{5pt}

The choice of this feature thus helps explore the correlation between economic factors and the severity of the pandemic's impact, offering critical and clear insights into the resilience and vulnerabilities of different counties. 

\vspace{10pt}

```{r K-means ground truth, echo=FALSE}
# Discretize COVID-19 deaths into categories
data_clustered_1 <- data_clustered_1 %>%
  mutate(death_category = cut(death_case_ratio, breaks = c(-Inf, 0.025, Inf), 
                              labels = c("Lower", "Higher")))

# Create a contingency table to compare clusters with death categories
cluster_comparison <- table(data_clustered_1$cluster, data_clustered_1$death_category)
print(cluster_comparison)
```

\captionof{figure}{Ground Truth Cluster Comparison}

\vspace{10pt}

#### Supervised Evaluation

The K-Means clustering plot shows how Texas counties are grouped into two distinct clusters (1 and 2). The features used for clustering are the death_case_ratio (the ratio of COVID-19 deaths to confirmed cases) and income_per_capita. The features were scaled to have a mean of zero and standard deviation of one, making sure that both features contribute equally to the clustering process. The difference between this clustering and the previous K-Means clustering is that this is supervised, meaning that the x and y axis are intentionally chosen to provide a simplified and clear result. The clusters represent groups of counties that share similar characteristics in terms of economic conditions and pandemic impact. Counties within each cluster exhibit more similarity to each other than to those in the other cluster. 

\vspace{10pt}

```{r k-means clustering supervised, echo=FALSE}
# Create a new feature 'death_case_ratio'
data <- data %>%
  mutate(death_case_ratio = deaths / confirmed_cases)

# Scale the selected features (excluding county_name)
scaled_data_kmean_sup <- data %>%
  select(death_case_ratio, income_per_capita) %>%
  scale(center = TRUE, scale = TRUE)

# Perform K-means clustering
kmeans_result <- kmeans(scaled_data_kmean_sup, centers = 2, nstart = 20)

# Append cluster assignments to the original data
data_clustered_2 <- data %>%
  mutate(cluster = as.factor(kmeans_result$cluster))

# Visualization of Clustering
fviz_cluster(kmeans_result, data = scaled_data_kmean_sup,
             geom = "point", ellipse.type = "convex",
             ggtheme = theme_minimal(), labelsize = 10) +
  labs(title = "K-Means Clustering of Texas Counties Supervised",
       x = "Death Case Ratio", y = "Income per Capita")
```

\captionof{figure}{K-Means Clustering of Texas Counties Supervised}

\vspace{10pt}

A summary statistics table, similar to the previous clustering method, is used to provide a detailed breakdown of the average values for key features across the two supervised clusters identified through K-Means clustering. Each cluster represents a distinct group of Texas counties with more similar economic, demographic, and pandemic characteristics. The table displays the average median income, income per capita, rent burden levels (both for households spending more than 50% and 30-35% of their income on rent), confirmed COVID-19 cases, deaths, and total population for each cluster.

```{r supervised k-means summary statistics by cluster, echo=FALSE, fig.cap="Summary Statistics by Cluster Supervised"}
# Calculate average values for each feature by cluster with adjusted column names
cluster_summary <- data_clustered_2 %>%
  group_by(cluster) %>%
  summarise(
    "Avg\nMedian\nIncome" = mean(median_income, na.rm = TRUE),
    "Avg\nIncome\nper Capita" = mean(income_per_capita, na.rm = TRUE),
    "Avg\nRent\n> 50%" = mean(rent_over_50_percent, na.rm = TRUE),
    "Avg\nRent\n30-35%" = mean(rent_30_to_35_percent, na.rm = TRUE),
    "Avg\nConfirmed\nCases" = mean(confirmed_cases, na.rm = TRUE),
    "Avg\nDeaths" = mean(deaths, na.rm = TRUE),
    "Avg\nDeath Case Ratio" = mean(death_case_ratio, na.rm = TRUE),
    "Total\nPopulation" = mean(total_pop, na.rm = TRUE)
  )

# Display the summary statistics table with narrower columns and smaller font size
kable(cluster_summary, format = "latex", caption = "Summary Statistics by Cluster", booktabs = TRUE) %>%
  kable_styling(latex_options = c("hold_position"), font_size = 7, full_width = FALSE) %>%
  column_spec(0:8, width = "1.25 cm")
```

\vspace{5pt}

This clustering uses interpretable features: death case ratio and income per capita. This makes the clusters more meaningful, reflecting the economic status directly. The data is more evenly distributed between the two clusters, providing a clearer separation of counties. Clusters 1 and 2 have a relatively even distribution of points, suggesting that the clustering is a good representation of the counties.

\vspace{5pt}

  - **Average Median Income:** Cluster 1 had an average median income of 58,917.73 USD and Cluster 2 had an average median income of 43,937.72 USD. This shows a very clear differentiation in economic status. The different is around 15,000 USD. 
  - **Average Death Case Ratio:** Cluster 1 has an average ratio of 0.0166 which is significantly lower than Cluster 2's average ratio of 0.0301. This highlights the relationship between economic conditions and pandemic outcomes more effectively. 
  
\vspace{5pt}

The two K-Means clustering analyses (supervised and unsupervised) aim to categorize Texas counties based on economic and pandemic-related features, but they differ significantly in terms of clarity, precision, and interpretability. 

\vspace{5pt}

Within Clusters 1 and 2, the counties are grouped based on their income and rent burdens. There are three income groups (Low: Income per Capita < 25,000 USD, Middle: 25,000 USD <= Income per Capita < 40,000 USD, High: Income per Capita > 40,000 USD) and two rent burden groups (Low: Rent over 50 Percent <= 5000, High: Rent over 50 Percent > 5000) that are used to provide more detailed comparison of the clusters. 

``` {r supervised grouping, echo = FALSE, message = FALSE, warning = FALSE}
# Create income level groups within clusters
data_clustered_2 <- data_clustered_2 %>%
  mutate(
    income_group = case_when(
      income_per_capita < 25000 ~ "Low Income",
      income_per_capita >= 25000 & income_per_capita < 40000 ~ "Middle Income",
      income_per_capita >= 40000 ~ "High Income"
    ),
    
    rent_burden_group = case_when(
      rent_over_50_percent > 5000 ~ "High Rent Burden",
      rent_over_50_percent <= 5000 ~ "Low Rent Burden"
    )
  )

# Summarize statistics for subgroups within each cluster
subgroup_summary <- data_clustered_2 %>%
  group_by(cluster, income_group, rent_burden_group) %>%
  summarise(
    "Avg Median Income" = mean(median_income, na.rm = TRUE),
    "Avg Income per Capita" = mean(income_per_capita, na.rm = TRUE),
    "Avg Death Case Ratio" = mean(death_case_ratio, na.rm = TRUE),
    "Total Population" = mean(total_pop, na.rm = TRUE)
  )

# Display the summary statistics table for subgroups
kable(subgroup_summary, format = "latex", caption = "Summary Statistics by Subgroups Within Clusters", booktabs = TRUE) %>%
  kable_styling(latex_options = c("hold_position"), font_size = 7, full_width = FALSE) %>%
  column_spec(0:8, width = "1.25 cm")
```

**Cluster 1 Analysis**

\vspace{5pt}

  - **Low Income & High Rent Burden:** With an average median income of approximately 39,219.50 USD and an average income per capita of 17,058.50 USD, this subgroup has a death per case ratio of 0.0258 and a relatively high population of about 591,047.25. This suggests that areas with low income and high rent burden may experience significant economic strain and relatively higher mortality rates.
  - **Low Income & Low Rent Burden:** This subgroup, with a slightly higher average median income of 43,140.55 USD and income per capita of 21,125.65 USD, has a death case ratio of 0.0279. The total population is notably lower at 23,914.66, which may indicate that smaller populations with low rent burden still faced considerable pandemic challenges.
  - **Middle Income & Low Rent Burden:** With the highest average median income and income per capita of Cluster 1, 48,879 USD and 26,590.88 respectively, the death per case ratio is 0.0419 which is the highest in Cluster 1. This could reflect that middle-income regions with low rent burdens still faced significant health challenges, potentially due to other socioeconomic or healthcare access factors.
  
\vspace{5pt}
  
**Cluster 2 Analysis**

  - **Low Income & High Rent Burden:** With an average median income of 46,262 USD and income per capita of 24,273 USD, this subgroup has a relatively lower death case ratio of 0.0157 compared to its Cluster 1 counterparts. This indicates that economic vulnerability did not translate to equally severe pandemic outcomes across all metrics.
  - **Low Income & Low Rent Burden:** This subgroup has an average median income of 46,604.71 USD and income per capita of 23,835.43 USD, with a low death case ratio of 0.0118. The total population is 26,067.43. The low rent burden appears to mitigate some of the negative effects of low income.
  - **Middle Income & High Rent Burden:** With a median income of 62,475.78 USD and income per capita of 30,879.67 USD, this subgroup shows a death case ratio of 0.0119. This indicates a significant economic uplift compared to low-income groups, with moderate resilience in pandemic outcomes despite high rent burdens.
  - **Middle Income & Low Rent Burden:** This subgroup has an average median income of 58,966.32 USD and income per capita of 29,439.27 USD, with a death case ratio of 0.0183. The lower rent burden may provide economic stability, but the death case ratio suggests room for improvement in health outcomes.
  - **High Income & High Rent Burden:** This subgroup stands out with a high average median income of 90,124 USD and income per capita of 41,609 USD. The death case ratio is the lowest at 0.0075, suggesting that wealthier areas with high rent burdens may have been better equipped to manage the pandemic’s impact. The total population in this group is substantial, at 914,075, indicating a dense but resilient economic region.
  
\vspace{5pt}

Higher income levels within Cluster 2 are associated with significantly lower death case ratios, highlighting the advantage of economic stability in managing the pandemic. Conversely, lower income groups in both clusters generally exhibit higher death case ratios. Rent burden appears to be a critical factor in economic vulnerability. However, even within high rent burden subgroups, those with higher income levels (Cluster 2) have better health outcomes. Subgroups with higher populations (e.g., high income, high rent burden areas in Cluster 2) show better resilience, possibly due to better infrastructure, healthcare access, and community resources.

\vspace{5pt}

The analysis reveals a clear relationship between income, rent burden, and pandemic outcomes. Wealthier areas, even with high rent burdens, were better at mitigating the negative impacts of COVID-19. These findings emphasize the importance of socioeconomic status and housing stability in public health crises. For stakeholders, this insight can guide investment and development decisions to prioritize areas with economic resilience or consider interventions to support vulnerable regions.

\vspace{5pt}

The following visualization illustrates the K-Means clustering results for Texas counties based on two critical features: the Death Case Ratio and Income per Capita. The clusters are color-coded and outlined with borders, representing the original cluster boundaries from the K-Means algorithm. Each point within the plot is labeled by income group and rent burden status, providing additional context about economic and housing conditions within each cluster.

\vspace{10pt}

``` {r supervised grouping on Cluster chart, echo = FALSE, message = FALSE, warning = FALSE}
# Plot the original Cluster boundaries without the points
plot_with_borders <- fviz_cluster(
  kmeans_result,
  data = scaled_data_kmean_sup,
  geom = "none",  # Exclude points
  ellipse.type = "convex",  # Draw convex cluster boundaries
  ggtheme = theme_minimal()
)

# Now, add the new groupings onto the plot with the cluster boundaries
ggplot(data_clustered_2, aes(x = scaled_data_kmean_sup[, 1], y = scaled_data_kmean_sup[, 2])) +
  # Add the cluster boundaries from the original plot
  plot_with_borders$layers[[1]] +
  geom_point(aes(color = income_group, shape = rent_burden_group), size = 3) +
  labs(
    title = "K-Means Clustering with Groupings",
    x = "Death Case Ratio",
    y = "Income per Capita"
  ) +
  theme_minimal() +
  scale_color_manual(values = c("Low Income" = "blue", "Middle Income" = "green", "High Income" = "red")) +
  scale_shape_manual(values = c(8, 18)) +  # Use different shapes: 16 (circle), 17 (triangle), 18 (diamond)
  theme(
    plot.title = element_text(hjust = 0.5, size = 14),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10)
  ) +
  guides(color = guide_legend(title = "Income Group"), shape = guide_legend(title = "Rent Burden Group"))
```
\captionof{figure}{K-Means Clustering with Groupings}

\vspace{10pt}

**Cluster 1 (Red Region)**
This cluster is characterized by a higher Death Case Ratio and generally lower ot middle Income per Capita. The blue points represent low-income groups, and the density of these points suggests a strong presence of economically vulnerable areas within this cluster. The green points, representing middle-income groups, are present but less dense compared to the low-income group. Notably, this cluster contains both high and low rent burden subgroups, with high rent burden subgroups (indicated by star-shaped markers) mixed throughout. This implies that some areas within this cluster experience compounded economic stress, both in terms of income and rent burden, which could exacerbate health outcomes.

\vspace{5pt}

**Cluster 2 (Blue Region)**
This cluster encompasses areas with a lower Death Case Ratio and generally higher Income per Capita. The red points indicate high-income areas, clustered toward the upper end of the income per capita axis, reflecting wealthier regions with better pandemic outcomes. There is a significant presence of green points representing middle-income groups, indicating that this cluster captures a range of moderately affluent areas. These areas seem to have fared better in terms of health outcomes compared to Cluster 1. High-income areas (red points) appear to have a mix of high and low rent burden groups, but even those with high rent burdens display relatively low Death Case Ratios. This suggests that wealthier regions, even with high rent burdens, may have had resources to mitigate the pandemic’s effects.

\vspace{5pt}

The clustering highlights a strong correlation between income and health resilience. Higher income per capita is associated with lower Death Case Ratios, likely due to better access to healthcare, resources, and infrastructure to manage health crises. Low-income areas, especially those burdened by high housing costs, appear more vulnerable. The presence of both low and high rent burden groups in Cluster 1 suggests that financial strain could amplify the negative impact of the pandemic. Middle-income areas straddle both clusters, indicating that not all middle-income regions experienced the pandemic uniformly. Factors beyond income, such as healthcare infrastructure, population density, or social support, could influence outcomes.

\vspace{5pt}

The following table presents the purity scores for the two different subgroup classifications: Income Groups and Rent Burden Groups. 

``` {r purity calcuations, echo = FALSE, warning = FALSE, message = FALSE}
# Calculate purity score
calculate_purity <- function(cluster_labels, true_labels) {
  # Combine the cluster and true labels into a data frame
  data_labels <- data.frame(cluster = cluster_labels, true_label = true_labels)
  
  # Group by clusters and find the most frequent label in each cluster
  majority_vote <- data_labels %>%
    group_by(cluster) %>%
    summarise(
      majority_label = names(sort(table(true_label), decreasing = TRUE)[1]),
      correct_count = max(table(true_label))
    )
  
  # Sum the counts of correctly classified data points
  total_correct <- sum(majority_vote$correct_count)
  
  # Compute purity score
  purity_score <- total_correct / nrow(data_labels)
  return(purity_score)
}

# Compute purity score for income groups
purity_income <- calculate_purity(data_clustered_2$cluster, data_clustered_2$income_group)

# Compute purity score for rent burden groups
purity_rent_burden <- calculate_purity(data_clustered_2$cluster, data_clustered_2$rent_burden_group)

# Create a data frame for the purity scores
purity_scores_df <- data.frame(
  Grouping = c("Income Groups", "Rent Burden Groups"),
  Purity_Score = c(purity_income, purity_rent_burden)
)

# Display the table using kable
kable(purity_scores_df, format = "latex", caption = "Purity Scores by Grouping", booktabs = TRUE) %>%
  kable_styling(full_width = FALSE, font_size = 10)
```

Purity is a metric used to evaluate the quality of clustering by measuring the extent to which clusters contain data points of a single class. A higher purity score indicates that the clusters are more homogeneous concerning the given grouping.

\vspace{5pt}

  - **Income:** A purity score of 0.870 indicates that 87.0 percent of the data points within clusters are correctly grouped based on their income level (Low, Middle, or High Income). The relatively high score suggests that the clustering model is effective in distinguishing counties based on income characteristics, but there is still a bit of overlap or misclassification. The presence of overlap could imply that income levels alone do not fully explain the clustering structure. 
  - **Rent Burden:** The purity score for rent burden classification is 90.6 percent, which is slightly higher than the score for income groups. This suggests that the clusters are even better at grouping counties based on housing affordability stress, indicated by whether they experience high or low rent burdens. This could mean that rent burden is a more distinct factor in the clustering analysis.

\vspace{5pt}

Both scores are relatively high, indicating that the K-Means clustering captures meaningful distinctions in the data. Given the high but not perfect purity scores, there may be other unexamined variables influencing the clusters. Additional socioeconomic or demographic factors could be considered in future models to further refine the clustering results.
Overall, the analysis suggests that while both income and rent burden are effective for understanding the clustering of Texas counties, housing stress appears to be a particularly significant and differentiating factor. This insight could be valuable for stakeholders aiming to address economic disparities or plan for community resilience.


### Heirarchical Clustering
```{r hierarchical clustering, echo=FALSE, warning=FALSE}
# Scale data for hierarchical clustering (excluding county_name)
scaled_data_hc <- data %>%
  select(-county_name) %>%
  scale()

# Calculate distance matrix and perform complete linkage clustering
distance_matrix <- dist(scaled_data_hc, method = "euclidean")
hc_complete <- hclust(distance_matrix, method = "complete")

# Plot the dendrogram
fviz_dend(hc_complete, k = 2,          # Number of clusters
          cex = 0.4,                   # Label size
          rect = TRUE,                 # Draw rectangles around clusters
          rect_fill = TRUE,            # Fill rectangles with cluster colors
          lwd = 0.6,                   # Thicker lines for clarity
          show_labels = FALSE) +       # Hide all labels for clarity
  labs(title = "Hierarchical Clustering Dendrogram (Complete Linkage)") +
  theme_minimal(base_size = 10)
```

```{r hierarchical summary, echo=FALSE}
# Assign clusters and calculate summary statistics for hierarchical clusters
hc_clusters <- cutree(hc_complete, k = 2)

data_clustered_hc <- data %>%
  mutate(cluster_hc = as.factor(hc_clusters))

# Summarize key statistics by hierarchical clusters
cluster_summary_hc <- data_clustered_hc %>%
  group_by(cluster_hc) %>%
  summarise(
    "Avg\nMedian\nIncome" = mean(median_income, na.rm = TRUE),
    "Avg\nIncome\nper Capita" = mean(income_per_capita, na.rm = TRUE),
    "Avg\nRent\n> 50%" = mean(rent_over_50_percent, na.rm = TRUE),
    "Avg\nRent\n30-35%" = mean(rent_30_to_35_percent, na.rm = TRUE),
    "Avg\nConfirmed\nCases" = mean(confirmed_cases, na.rm = TRUE),
    "Avg\nDeaths" = mean(deaths, na.rm = TRUE),
    "Total\nPopulation" = mean(total_pop, na.rm = TRUE)
  )

# Display summary table
kable(cluster_summary_hc, format = "latex", caption = "Summary Statistics by Hierarchical Cluster", booktabs = TRUE) %>%
  kable_styling(latex_options = c("hold_position"), font_size = 7, full_width = FALSE) %>%
  column_spec(0:7, width = "1.5cm")
```

#### Suitable Number of Clusters
The Elbow Method plots the WSS (Within-Cluster Sum of Squares) for different number of clusters. WSS measures how tightly the data points are grouped around the centroids of the clusters. After a certain point, adding more clusters provides diminishing returns, meaning the reduction in WSS becomes negligible. The optimal number of clusters is found at the "elbow" point, where the rate of decrease in WSS sharply levels off. In the following elbow plot, the elbow occurs around 2 clusters. 
```{r heirarchical optimal cluster elbow, echo=FALSE}
# Elbow Method
# Load necessary libraries
library(cluster)
library(factoextra)

# Create the distance matrix and hierarchical clustering
distance_matrix <- dist(scaled_data_hc, method = "euclidean")
hc_complete <- hclust(distance_matrix, method = "complete")

# Specify the range of clusters (e.g., 2 to 10)
max_clusters <- 10

# Use hcut to evaluate within-cluster sum of squares for hierarchical clustering
fviz_nbclust(scaled_data_hc, hcut, method = "wss", k.max = max_clusters) +
  labs(title = paste("Elbow Method for Hierarchical Clustering"))
```

The Silhouette Method evaluates how well each data point fits within its assigned cluster compared to other clusters. The Silhouette score ranges from -1 to 1, with values close to 1 meaning that the points are well-clustered. In the following Silhouette chart, the peak occurs at 2 clusters. 
```{r heirarchical optimal cluster silhouette, echo=FALSE}
# Silhouette Method
# Assign clusters with cutree (for k = 2 to 6 clusters)
silhouette_scores <- map(2:6, function(k) {
  clusters <- cutree(hc_complete, k = k)
  silhouette(clusters, distance_matrix)
})

# Visualize the silhouette scores for different numbers of clusters
fviz_nbclust(scaled_data_hc, FUN = hcut, method = "silhouette") +
  labs(title = "Silhouette Method for Hierarchical Clustering")
```


After considering both of these models, it was decided to do 2 clusters. Because of the consistency across both methods, 2 cluters was the clear choice. 

#### Unsupervised Evaluation
```{r hierarchical silhouette analysis, echo=FALSE}
# Calculate silhouette scores for hierarchical clusters
silhouette_scores <- silhouette(hc_clusters, distance_matrix)

# Plot silhouette scores
fviz_silhouette(silhouette_scores) +
  labs(title = "Silhouette Plot for Hierarchical Clustering (Complete Linkage)",
       x = "Silhouette Width", y = "Clusters")
```

```{r hierarchical comaprison of linkage methods, echo=FALSE}
# Perform clustering with alternative linkage methods
hc_average <- hclust(distance_matrix, method = "average")
hc_ward <- hclust(distance_matrix, method = "ward.D2")

# Plot alternative linkage dendrograms
par(mfrow = c(1, 2))  # Side-by-side layout
fviz_dend(hc_average, k = 2, rect = TRUE, rect_fill = TRUE, main = "Hierarchical Clustering (Average Linkage)")
fviz_dend(hc_ward, k = 2, rect = TRUE, rect_fill = TRUE, main = "Hierarchical Clustering (Ward's Linkage)")
par(mfrow = c(1, 1))  # Reset layout

```

```{r average silhouette width, echo=FALSE}
# Calculate average silhouette widths for each linkage method
silhouette_complete <- mean(silhouette(cutree(hc_complete, k = 2), distance_matrix)[, 2])
silhouette_average <- mean(silhouette(cutree(hc_average, k = 2), distance_matrix)[, 2])
silhouette_ward <- mean(silhouette(cutree(hc_ward, k = 2), distance_matrix)[, 2])

# Summarize silhouette widths
silhouette_summary <- data.frame(
  Linkage_Method = c("Complete", "Average", "Ward's"),
  Avg_Silhouette_Width = c(silhouette_complete, silhouette_average, silhouette_ward)
)

# Display silhouette summary table
kable(silhouette_summary, format = "markdown", caption = "Average Silhouette Widths by Linkage Method") %>%
  kable_styling(full_width = FALSE, font_size = 8.5)
```

#### Ground Truth Feature
```{r heirarchical ground truth, echo=FALSE}
# Step 1: Assign hierarchical clusters (k = 2) to the data
data_clustered_hc <- data %>%
  mutate(cluster_hc = cutree(hc_complete, k = 2))

# Step 2: Discretize COVID-19 deaths into categories (Low, Medium, High)
data_clustered_hc <- data_clustered_hc %>%
  mutate(death_category = cut(death_case_ratio, breaks = c(-Inf, 0.025, Inf), 
                              labels = c("Lower", "Higher")))

# Step 3: Create a contingency table to compare clusters with death categories
cluster_comparison_hc <- table(data_clustered_hc$cluster_hc, data_clustered_hc$death_category)

# Step 4: Print the contingency table
print(cluster_comparison_hc)
```

#### Supervised Evaluation

```{r hierarchical clustering supervised, echo=FALSE}
# Scale data for hierarchical clustering using selected features
scaled_data_hc_sup <- data %>%
  select(death_case_ratio, income_per_capita) %>%
  scale(center = TRUE, scale = TRUE)

# Perform hierarchical clustering with Ward's method
distance_matrix <- dist(scaled_data_hc_sup, method = "euclidean")
hc_ward <- hclust(distance_matrix, method = "ward.D")

# Plot the dendrogram with Ward's method
fviz_dend(hc_ward, k = 2,          # Number of clusters
          cex = 0.4,               # Label size
          rect = TRUE,             # Draw rectangles around clusters
          rect_fill = TRUE,        # Fill rectangles with cluster colors
          lwd = 0.6,               # Thicker lines for clarity
          show_labels = FALSE) +   # Hide all labels for clarity
  labs(title = "Hierarchical Clustering Dendrogram Supervised") +
  theme_minimal(base_size = 10)
```

```{r hierarchical summary supervised, echo=FALSE}
# Assign clusters based on the updated hierarchical clustering with Ward's method
hc_clusters <- cutree(hc_ward, k = 2)

# Add cluster labels to the original data
data_clustered_hc <- data %>%
  mutate(cluster_hc = as.factor(hc_clusters))

# Summarize key statistics by hierarchical clusters
cluster_summary_hc <- data_clustered_hc %>%
  group_by(cluster_hc) %>%
  summarise(
    "Avg\nMedian\nIncome" = mean(median_income, na.rm = TRUE),
    "Avg\nIncome\nper Capita" = mean(income_per_capita, na.rm = TRUE),
    "Avg\nRent\n> 50%" = mean(rent_over_50_percent, na.rm = TRUE),
    "Avg\nRent\n30-35%" = mean(rent_30_to_35_percent, na.rm = TRUE),
    "Avg\nConfirmed\nCases" = mean(confirmed_cases, na.rm = TRUE),
    "Avg\nDeaths" = mean(deaths, na.rm = TRUE),
    "Avg\nDeath Case Ratio" = mean(death_case_ratio, na.rm = TRUE),
    "Total\nPopulation" = mean(total_pop, na.rm = TRUE)
  )

# Display the summary table
kable(cluster_summary_hc, format = "latex", caption = "Summary Statistics by Hierarchical Cluster (Supervised)", booktabs = TRUE) %>%
  kable_styling(latex_options = c("hold_position"), font_size = 7, full_width = FALSE) %>%
  column_spec(0:8, width = "1.25 cm")
```



\newpage

# Population Data in Texas Counties/Layer 2 Clustering
## Data Collection, Quality, and Exploration
### Objects to Cluster

The first part of the report clustered for the best performing affluent counties using the death to cases ratio and income per capita. Our model takes these optimal clusters of counties (cluster "2" in both methodologies for prior layer of clustering) and applies a second layer of clustering using the same methods.

That is to say, each methodology, K-means and Hierarchical, in this second layer receives cluster "2" from its prior layer and applies itself again (e.g. The K-means method in this layer applies itself to cluster "2" of the K-means result for death to cases ratio and income per capita).

```{r, echo=FALSE}
# Load up data as r objects
olivia_cluster_kmeans_data <- readRDS("Barcelo/RDS/olivia_cluster_kmeans.rds")
olivia_cluster_kmeans_two_var <- olivia_cluster_kmeans_data %>% select(county_name, cluster)
olivia_cluster_hierarchical_data <- readRDS("Barcelo/RDS/olivia_cluster_hierarchical.rds")
olivia_cluster_hierarchical_two_var <- olivia_cluster_hierarchical_data %>% select(county_name, cluster_hc)
county_data_set.scaled <- readRDS("Barcelo/RDS/county_data_set_cluster.scaled.rds")
county_data_set <- readRDS("Barcelo/RDS/county_data_set_cluster.rds")
```

```{r, echo=FALSE}

# Combine data to make tables we are going to use
county_data_set <- county_data_set %>% select(-kmeans_cluster, -hierarchachal_cluster) %>% left_join(olivia_cluster_kmeans_two_var, by = "county_name") %>% left_join(olivia_cluster_hierarchical_two_var, by = "county_name") %>% rename(olivia_cluster_kmeans = "cluster") %>% rename(olivia_cluster_hc = "cluster_hc")

county_data_set.scaled <- county_data_set.scaled %>% select(-kmeans_cluster, -hierarchachal_cluster) %>% left_join(olivia_cluster_kmeans_two_var, by = "county_name") %>% left_join(olivia_cluster_hierarchical_two_var, by = "county_name") %>% rename(olivia_cluster_kmeans = "cluster") %>% rename(olivia_cluster_hc = "cluster_hc")
```

```{r, echo=FALSE}
# Filter for olivia second cluster only

filtered_kmeans_county_data_set <- county_data_set %>% filter(olivia_cluster_kmeans == 2) %>% select(-olivia_cluster_hc)
filtered_kmeans_county_data_set.scaled <- county_data_set.scaled %>% filter(olivia_cluster_kmeans == 2) %>% select(-olivia_cluster_hc)

filtered_hierarchical_county_data_set <- county_data_set %>% filter(olivia_cluster_hc == 2) %>% select(-olivia_cluster_kmeans)
filtered_hierarchical_county_data_set.scaled <- county_data_set.scaled %>% filter(olivia_cluster_hc == 2) %>% select(-olivia_cluster_kmeans)
```

### Features for Clustering

The feature set for this second layer on which our K-means and Hierarchical methods apply themselves are population density and COVID-19 cases per thousand. This is done in order to find the highest population density counties with the lowest amount of COVID-19 cases.

 -**Population Density** Found by first obtaining the total population for each Texas county using the Tidycensus R package, and then using census.gov's 2023 Geographic info API to retrieve the variable AREALAND_SQMI (land area in square miles) for each county in Texas. The total population for each county was divided by the total land area in square miles to create the population density feature (people per square mile of land).
 -**Cases per Thousand** Found by taking total cases from COVID-19 Texas data set and dividing by total population for each county.

### Table of Features and Basic Statistics

```{r, echo=FALSE}
basic_stats_pop <- county_data_set %>% select(total_deaths, total_cases, total_population, area_sqmiles, pop_density, deaths_per_k, cases_per_k) %>% summary()

basic_stats_pop <- as.data.frame(basic_stats_pop)

basic_stats_pop <- basic_stats_pop %>% separate(Freq , into = c("stat", "num"), sep = ":") %>% pivot_wider(names_from = stat, values_from = num) %>% rename(Feature = "Var2") %>% select(-Var1)

basic_stats_pop$Feature <- c("Total Deaths", "Total Cases", "Total Population", "Area in Square Miles", "Population Density","Deaths per Thousand", "Cases per Thousand")

kable(basic_stats_pop, format = "markdown", caption = "Basic Statistics for Features") %>%
  kable_styling(full_width = FALSE, font_size = 10)
```

### Scale of Measurement

```{r, echo=FALSE}
all_features_pop <- c("County Name", basic_stats_pop$Feature)
scale_pop <- c("Nominal", rep("Ratio", 7))
description_pop <- c("Name of the county", "Total Amount of Deaths in the County", "Total Amount of Cases in the County", "Total Population of the County", "Area of county in Square Miles", "Population Density in People per Square Mile", "Covid Deaths per Thousand Inhabitants", "Covid Cases per Thousand Inhabitants")

scale_of_measurement_pop <- cbind(all_features_pop, scale_pop, description_pop)
scale_of_measurement_pop <- as.data.frame(scale_of_measurement_pop) %>% rename(Features = "all_features_pop", Scale = "scale_pop", Description = "description_pop")

kable(scale_of_measurement_pop, format = "markdown", caption = "Measurement Scales for Features") %>%
  kable_styling(full_width = FALSE, font_size = 10)
```


### Measures for Similarity/Distance

Since the clustering uses K-means and Hierarchical methodologies, Euclidean distance is used. Here are first-five-counties-in-the-data-set's euclidean distance for population density and cases per thousand.

```{r, echo=FALSE}
dist(filtered_hierarchical_county_data_set %>% select(pop_density, cases_per_k) %>% slice_head(n = 5), method = "euclidean")
```

### Normalization/Standardization

Numeric features in the data set were normalized using R's scale function, which normalizes a distribution using a standard Z-score normalization.

## Modeling and Evaluation
### K-Means Clustering

```{r, echo=FALSE}
counties_kmeans_pop_dens_et_cases_per_k <- filtered_kmeans_county_data_set %>% select(county_name, pop_density, cases_per_k)
counties_kmeans_pop_dens_et_cases_per_k.scaled <- filtered_kmeans_county_data_set.scaled %>% select(county_name, pop_density, cases_per_k)
```

```{r, echo=FALSE}
pop_dense_and_cases_kmeans <- kmeans(counties_kmeans_pop_dens_et_cases_per_k.scaled %>% select(where(is.numeric)), centers = 2)

fviz_cluster(pop_dense_and_cases_kmeans, data = counties_kmeans_pop_dens_et_cases_per_k.scaled %>% select(where(is.numeric)),
             geom = "point", ellipse.type = "convex",
             ggtheme = theme_minimal(), labelsize = 10) +
  labs(title = "K-Means Clustering of Texas Counties (in cluster \"2\" of Prior K-means Layer)\nbased off Population Density and Cases per Thousand",
       x = "Population Density", y = "Cases per Thousand")
```

Our K-means clustering seemingly divides the data into low cases-per-thousand and high cases-per-thousand.


```{r, echo=FALSE}
# Make data set include this kmeans cluster

filtered_kmeans_county_data_set_clustered <- filtered_kmeans_county_data_set %>% mutate(matias_kmeans = as.factor((pop_dense_and_cases_kmeans$cluster)))
filtered_kmeans_county_data_set_clustered.scaled <- filtered_kmeans_county_data_set.scaled %>% mutate(matias_kmeans = as.factor((pop_dense_and_cases_kmeans$cluster)))
```

#### Suitable Number of Clusters

Elbow Method

```{r, echo=FALSE}
fviz_nbclust(counties_kmeans_pop_dens_et_cases_per_k.scaled %>% select(where(is.numeric)), kmeans, method = "wss") +
  labs(title = "Elbow Method for Determining Optimal Clusters for Pop Density and\nCases per Thousand for K-means Clustering") +
  geom_vline(xintercept = 2, color = "blue", linetype = "dashed", size = 1)
```

Silhouette Method

```{r, echo=FALSE}
fviz_nbclust(counties_kmeans_pop_dens_et_cases_per_k.scaled %>% select(where(is.numeric)), kmeans, method = "silhouette") +
  labs(title = "Silhouette Method or Determining Optimal Clusters for Pop Density\nand Cases per Thousand for Kmeans Clustering")
```

Our Elbow and Silhouette methods suggest our optimal amount of clusters for K-means is 2 clusters.

#### Unsupervised Evaluation

Silhouette Width

```{r, echo=FALSE}
library(cluster)
```

```{r, echo=FALSE}
plot(silhouette(pop_dense_and_cases_kmeans$cluster, dist(counties_kmeans_pop_dens_et_cases_per_k.scaled %>% select(where(is.numeric)))), main = "Silhouette Plot of Population Density by Euclidean Distance\nin Current Layer Kmeans Clustering")
```

Our Average Silhouette width is not close to 1, which means that the centroids may not be as close to the middle of the cluster as they could be; however, the distribution of data points are fair.

Summary Statistics

```{r, echo=FALSE}
summary_data_kmeans <- olivia_cluster_kmeans_data %>% rename(olivia_cluster_kmeans = cluster) %>% left_join(county_data_set %>% select(county_name, pop_density, cases_per_k, deaths_per_k), by = join_by(county_name)) %>% left_join(filtered_kmeans_county_data_set_clustered %>% select(county_name, matias_kmeans), by = join_by(county_name))

k_means_cluster_summary <- summary_data_kmeans %>%
  group_by(matias_kmeans) %>%
  drop_na() %>%
  rename(layer_2_kmeans = "matias_kmeans") %>%
  summarise(
    "Avg\nCases\nper\nthousand" = mean(cases_per_k, na.rm = TRUE),
    "Avg\nDeaths\nper\nthousand" = mean(deaths_per_k, na.rm = TRUE),
    "Avg\nPopulation\nDensity" = mean(pop_density, na.rm = TRUE),
    "Number\nof\nCounties" = n()
  )

kable(k_means_cluster_summary, format = "latex", caption = "Summary Statistics for K-means Cluster based on Population Density and Cases per Thousand", booktabs = TRUE) %>%
  kable_styling(latex_options = c("hold_position"), font_size = 7, full_width = FALSE) %>%
  column_spec(0:8, width = "1.25 cm")
```

As mentioned earlier, the second layer of K-means clustering seemingly prioritized cases-per-thousands over population density.

#### Ground Truth Feature

#### Supervised Evaluation

### Heirarchical Clustering

```{r, echo=FALSE}
counties_hierarchical_pop_dens_et_cases_per_k <- filtered_hierarchical_county_data_set %>% select(county_name, pop_density, cases_per_k)
counties_hierarchical_pop_dens_et_cases_per_k.scaled <- filtered_hierarchical_county_data_set.scaled %>% select(county_name, pop_density, cases_per_k)
```

Dendogram

```{r, echo=FALSE}
pop_dense_and_cases_hierarchical <- hclust(dist(counties_hierarchical_pop_dens_et_cases_per_k.scaled), method = "complete")
fviz_dend(pop_dense_and_cases_hierarchical, show_labels = FALSE, main = "Hierarchical Clustering based off Population Density and Cases per Thousand")
```

```{r, echo=FALSE}
fviz_dend(pop_dense_and_cases_hierarchical, k = 2, show_labels = FALSE, main = "Hierarchical Clustering based off Population Density and Cases per Thousand")
```

```{r, echo=FALSE}
pop_dense_and_cases_hierarchical_cut <- cutree(pop_dense_and_cases_hierarchical, k = 2)

fviz_cluster(list(data = counties_hierarchical_pop_dens_et_cases_per_k.scaled %>% select(where(is.numeric)), cluster = pop_dense_and_cases_hierarchical_cut), geom = "point", ellipse.type = "convex",
             ggtheme = theme_minimal(), labelsize = 10) +
  labs(title = "Hierarchical Clustering of Texas Counties (in cluster \"2\" of Prior Hierarchical Layer)\nbased off Population Density and Cases per Thousand",
       x = "Population Density", y = "Cases per Thousand")
```

The second layer Hierarchical clustering seemingly divides the data into high and low population density.

#### Suitable Number of Clusters

Elbow

```{r, echo=FALSE}
fviz_nbclust(counties_hierarchical_pop_dens_et_cases_per_k.scaled %>% select(where(is.numeric)), hcut, method = "wss") +
  labs(title = "Elbow Method for Determining Optimal Clusters for Pop Density and\nCases per Thousand for Hierarchical Clustering") +
  geom_vline(xintercept = 2, color = "blue", linetype = "dashed", size = 1)
```

Silhouette Method

```{r, echo=FALSE}
fviz_nbclust(counties_hierarchical_pop_dens_et_cases_per_k.scaled %>% select(where(is.numeric)), hcut, method = "silhouette") +
  labs(title = "Silhouette Method or Determining Optimal Clusters for Pop Density\nand Cases per Thousand for Hierarchical Clustering")
```

Our Elbow and Silhouette methods suggest our Hierarchical Dendogram be cut at 2 clusters.

#### Unsupervised Evaluation

```{r, echo=FALSE}
filtered_hierarchical_county_data_set_clustered <- filtered_hierarchical_county_data_set %>% mutate(matias_hierarchical = pop_dense_and_cases_hierarchical_cut)
filtered_hierarchical_county_data_set_clustered.scaled <- filtered_hierarchical_county_data_set.scaled %>% mutate(matias_hierarchical = pop_dense_and_cases_hierarchical_cut)
```

Silhouette Plot

```{r, echo=FALSE}
plot(silhouette(pop_dense_and_cases_hierarchical_cut, dist(counties_hierarchical_pop_dens_et_cases_per_k.scaled%>% select(where(is.numeric)))), main = "Silhouette Plot of Population Density by Euclidean Distance\nin Current Layer Hierarchical Clustering")
```

Our average silhouette widths are close to 1, which means the centroids are close to the center of the clusters; however, the distribution of data points in the cluster are very lop sided in favor of the low population density cluster.

Summary Statistics

```{r, echo=FALSE}
summary_data_hierarchical <- olivia_cluster_kmeans_data %>% rename(olivia_cluster_kmeans = cluster) %>% left_join(county_data_set %>% select(county_name, pop_density, cases_per_k, deaths_per_k), by = join_by(county_name)) %>% left_join(filtered_hierarchical_county_data_set_clustered %>% select(county_name, matias_hierarchical), by = join_by(county_name))

hierarchical_cluster_summary <- summary_data_hierarchical%>%
  group_by(matias_hierarchical) %>%
  drop_na() %>%
  rename(layer_2_hierarchical = "matias_hierarchical") %>%
  summarise(
    "Avg\nCases\nper\nthousand" = mean(cases_per_k, na.rm = TRUE),
    "Avg\nDeaths\nper\nthousand" = mean(deaths_per_k, na.rm = TRUE),
    "Avg\nPopulation\nDensity" = mean(pop_density, na.rm = TRUE),
    "Number\nof\nCounties" = n()
  )

kable(hierarchical_cluster_summary, format = "latex", caption = "Summary Statistics for Hierarchical Cluster based on Population Density and Cases per Thousand", booktabs = TRUE) %>%
  kable_styling(latex_options = c("hold_position"), font_size = 7, full_width = FALSE) %>%
  column_spec(0:8, width = "1.25 cm")
```

As mentioned earlier, the distribution of number of counties in a cluster could be better; however, the three counties found in the second county have a notably low deaths per thousand despite clustering for cases per thousand.

#### Ground Truth Feature

#### Supervised Evaluation

\newpage

# Exceptional Work
## Data Collection, Quality, and Exploration
### Objects to Cluster

### Features for Clustering

### Table of Features and Basic Statistics

### Scale of Measurement

### Measures for Similarity/Distance

### Normalization/Standardization


## Modeling and Evaluation
### Clustering _____

#### Suitable Number of Clusters

#### Unsupervised Evaluation

#### Ground Truth Feature

#### Supervised Evaluation

### Clustering ______

#### Suitable Number of Clusters

#### Unsupervised Evaluation

#### Ground Truth Feature

#### Supervised Evaluation


\newpage

# Recommendations
*Discuss how the model can be interpreted and the recommendations based on the findings. Explain the utility for the stakeholders.*

After analyzing our model's results, if a client has an interest in opening a business in an affluent, high land population density, and high COVID-19 performing county in Texas, they should consider the following counties.

After taking cluster "1" in the second layer K-means cluster, and sorting from descending order according to population density the three top counties are:

```{r, echo=FALSE}
top_3_kmeans <- summary_data_kmeans %>% filter(matias_kmeans == 1) %>% rename(layer_2_kmeans = "matias_kmeans") %>% arrange(desc(pop_density)) %>% slice_head(n = 3) %>% select(county_name)

# Display the summary statistics table with narrower columns and smaller font size
kable(top_3_kmeans, format = "latex", caption = "Summary Statistics by Cluster", booktabs = TRUE) %>%
  kable_styling(latex_options = c("hold_position"), font_size = 7, full_width = FALSE) %>%
  column_spec(0:8, width = "1.25 cm")
```

The three results in cluster "2" for the second layer hierarchical clustering were:

```{r, echo=FALSE}
top3_hierarchical <- summary_data_hierarchical %>% filter(matias_hierarchical == 2) %>% rename(layer_2_hierarchical = "matias_hierarchical") %>% arrange(desc(pop_density)) %>% select(county_name)

# Display the summary statistics table with narrower columns and smaller font size
kable(top3_hierarchical, format = "latex", caption = "Summary Statistics by Cluster", booktabs = TRUE) %>%
  kable_styling(latex_options = c("hold_position"), font_size = 7, full_width = FALSE) %>%
  column_spec(0:8, width = "1.25 cm")
```

```{r, echo=FALSE}
top_counties <- top_3_kmeans %>% full_join(top3_hierarchical)

summary_data_recommendation <- summary_data_kmeans %>% filter(county_name %in% top_counties$county_name) %>% arrange(desc(pop_density)) %>% select(county_name, total_pop, median_income, income_per_capita, rent_over_50_percent, rent_30_to_35_percent, confirmed_cases, deaths, cases_per_k, deaths_per_k, death_case_ratio, total_pop, pop_density) %>% rename("County\nName" = "county_name", "Total\nPopulation" = "total_pop", "Median\nIncome" = "median_income", "Income\nPer\nCapita" = "income_per_capita", "Rent\n30-35%" = "rent_30_to_35_percent", "Rent\nOver\n50%" = "rent_over_50_percent", "Confirmed\nCases" = "confirmed_cases", "Confirmed\nDeaths" = "deaths", "Cases\nper\nThousand" = "cases_per_k", "Deaths\nPer\nThousand"= "deaths_per_k", "Death\nCase\nRatio" = "death_case_ratio", "Population\nDensity" = "pop_density")

# Display the summary statistics table with narrower columns and smaller font size

kable(summary_data_recommendation, format = "latex", caption = "Summary Statistics by Cluster", booktabs = TRUE) %>%
  kable_styling(latex_options = c("hold_position"), font_size = 7, full_width = FALSE) %>%
  column_spec(0:8, width = "1.25 cm")
```

*Describe your results. What recommendations can you formulate based on the clustering results? How do these recommendations relate to the ones already presented in report 1? What findings are the most interesting to your stakeholder?*

\newpage

# Conclusion
*Summarize the key findings and their relevance to the initial questions.*

\newpage

# List of References
[1] “Covid-19,” NFID, [https://www.nfid.org/infectious-diseases/covid-19/](https://www.nfid.org/infectious-diseases/covid-19/) (accessed Oct. 8, 2024).

[2] Northwestern Medicine, “Covid-19 pandemic timeline,” Northwestern Medicine, [https://www.nm.org/healthbeat/medical-advances/new-therapies-and-drug-trials/covid-19-pandemic-timeline](https://www.nm.org/healthbeat/medical-advances/new-therapies-and-drug-trials/covid-19-pandemic-timeline) (accessed Oct. 8, 2024).

[3] “10.1 - hierarchical clustering,” 10.1 - Hierarchical Clustering | STAT 555, [https://online.stat.psu.edu/stat555/node/85/#:~:text=For%20most%20common%20hierarchical%20clustering,when%20they%20are%20perfectly%20correlated.](https://online.stat.psu.edu/stat555/node/85/#:~:text=For%20most%20common%20hierarchical%20clustering,when%20they%20are%20perfectly%20correlated.) (accessed Oct. 23, 2024). 

[4] “Manhattan distance,” Wikipedia, [https://simple.wikipedia.org/wiki/Manhattan_distance](https://simple.wikipedia.org/wiki/Manhattan_distance) (accessed Oct. 23, 2024). 

[5] A. Jain, “Normalization and standardization of Data,” Medium,  
[https://medium.com/@abhishekjainindore24/normalization-and-standardization-of-data-408810a88307](https://medium.com/@abhishekjainindore24/normalization-and-standardization-of-data-408810a88307) (accessed Oct. 23, 2024).

\newpage

# Appendix
*Include code snippets, extended tables, or other supplementary information.*

## Student Contributions
Olivia Hofmann

  - Format/Organization of Report (Lead)
  - Problem Description (Lead)
  - Income Data in Texas Counties (Lead)
  - Exceptional Work (Supporter)
  
Mike Perkins

  - Format/Organization of Report (Supporter)
  - Exceptional Work (Lead)
  
Matias Barcelo

  - Format/Organization of Report (Supporter)
  - Population Data in Texas Counties (Lead)

## Extra Graduate Student Work
*For each graduate students: Describe your exceptional work in a few sentences.*

The graduate students in this group are Olivia Hofmann and Mike Perkins. Both graduate students worked together to ensure the report was held to a high standard and complete the exceptional work clustering. 
